---
title: 数据结构小结(1)
date: 2019-01-08 11:47:06
tags: ds , data sturcture
---
# 数据结构
## 性能度量
> 算法的时间复杂度和空间复杂度合称为算法的复杂度。
### 时间复杂度

1. 时间频度 一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。

2. 时间复杂度 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用$T(n)$表示，若有某个辅助函数$f(n)$,使得当$n$趋近于无穷大时，${\frac{T(n)}{f(n)}}$的极限值为不等于零的常数，则称$f(n)$是$T(n)$的同数量级函数。记作$T(n)=O(f(n))$,称$O(f(n))$为算法的渐进时间复杂度，简称时间复杂度。
	常见的时间复杂度有：常数阶$O(1)$,对数阶$O(log_{2}n)$,线性阶$O(n)$, 线性对数阶$O(n\cdot log_{2}n)$,平方阶O(n^{2})，立方阶O(n^{3}),…， k次方阶O(n^{k}),指数阶O(k^{n})。
3. 最坏时间复杂度和平均时间复杂度 　最坏情况下的时间复杂度称最坏时间复杂度。一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。
4. 记号
	渐进精确记号$\Theta(n)$
	渐进上界记号$O(n)$
	渐进下界记号$\Omega(n)$
5. 求时间复杂度
	1. 如果算法的执行时间不随着问题规模n的增加而增长,此类算法的时间复杂度是O(1)。
		``` cpp
		x=91;
		y=100;
		while(y>0)
		    if(x>100) {
		    x=x-10;
		    y--;
		}
		else {
		    x++;
		}
		```
		解答： $T(n)=O(1)$，

	2. 当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。
		```cpp
		x=1;
		for(i=1;i<=n;i++)
		   for(j=1;j<=i;j++)
		      for(k=1;k<=j;k++)
		          x++;
		```

		该程序段中频度最大的语句是`x++`，则该程序段的时间复杂度为$T(n)=O(n3/6+$ 低次项 $)=O(n3)$

      1. 算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。

	5. 时间复杂度评价性能
	一般将渐近时间复杂度$T(n)=O(f(n))$简称为时间复杂度，其中的$f(n)$一般是算法中频度最大的语句频度。
### 空间复杂度
	一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分。　　
	1. 固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。
	2. 可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。
		> 一个算法所需的存储空间用$f(n)$表示。$S(n)=O(f(n))　$　其中$n$为问题的规模，$S(n)$表示空间复杂度。

## 数组
抽象数据类型（Abstract Data Type，ADT）
``` cpp
class  GeneralArray {
// a set of pairs <index, value> where for each value of
index in IndexSet there is a value of type float. IndexSet is a finite ordered set of one or more dimensions.
public:
    GeneralArray(int j, RangeList list, float initValue = defaultValue);
// This constructor creates a j dimensional array of floats; the range of the kth dimension is given by the kth element of list. For all i∈IndexSet, insert <i, initValue> into the array.
    float  Retrieve(index i);
// if (i∈IndexSet) return the float associated with i in the array;else throw an exception.
    void Store(index i, float x);
// if (i∈IndexSet) replace the old value associated with i by x;  else throw an exception.
}; //end of GeneralArray
```
### 顺序表
* 多项式
  * 基本操作：求长度、遍历、取数、存数、插入、删除
基本结构

``` cpp
class Polynomial; // forward declaration
class Term {
friend Polynomial;
private:
     float coef; // coefficient
     int exp;     // exponent
};
class Polynomial {
public:
	///...
  private:
   Term *termArray;
   int capacity; // size of termArray
   int terms; // number of nonzero terms
}

Polynomial Polynomial::Add(Polynomial b)
{ // return the sum of the polynomials *this and b.
	Polynomial c;
	int aPos = 0, bPos = 0;
	while ((aPos < terms) && (b < b.terms))
		if (termArray[aPos].exp == b.termArray[bPos].exp)
		{
			float t = termArray[aPos].coef + termArray[bPos].coef;
			if (t)
				c.NewTerm(t, termArray[aPos].exp);
			aPos++;
			bPos++;
		}
		else if (termArray[aPos].exp < b.termArray[bPos].exp)
		{
			c.NewTerm(b.termArray[bPos].coef,b.termArray[bPos].exp);
			bPos++;
		}
		else
		{
			c.NewTerm(termArray[aPos].coef, termArray[aPos].exp);
			aPos++;
		}
	// add in the remaining terms of *this
	for (; aPos < terms; aPos++)
		c.NewTerm(termArray[aPos].coef, termArray[aPos].exp);
	// add in the remaining terms of b
	for (; bPos < b.terms; bPos++)
		c.NewTerm(b.termArray[bPos].coef, b.termArray[bPos].exp);
	return c;
}
void Polynomial::NewTerm(const float theCoeff,const int theExp)
{ // add a new term to the end of termArray.
	if (terms == capacity)
	{ // double capacity of termArray
		capacity *= 2;
		term *temp = new term[capacity]; // new array
		copy(termArray, termAarry + terms, temp);
		delete[] termArray; // deallocate old memory
		termArray = temp;
	}
	termArray[terms].coef = theCoeff;
	termArray[terms++].exp = theExp;
}
```
* 时间复杂度分析：
  * 插入：
    * 无需翻倍时：$O(1)$
    * 翻倍时（内存不足）:$O(m + n +$ 在数组加倍中花费的时间 $)$
  * 翻倍（内存扩容）：
    * $$O(\sum_{i=1}^{k}{2^{i}})=O(2^{k+1})=O(2^{k})$$
    * 由于 $c.terms>2^{k-1}$ , $m+n\in c.terms$实际使用时间为$O(c.terms)=O(m+n)$

### 稀疏矩阵
``` cpp
class SparseMatrix
 { // a set of <row, column, value>, where row, column are non-negative integers and form a unique combination; value is also an integer.
 public:
      SparseMatrix ( int r, int c, int t);
      // creates a r∈c SparseMatrix with a capacity of t nonzero terms
      SparseMatrix Transpose ( );
      // return the SparseMatrix obtained by transposing *this
      SparseMatrix  Add ( SparseMatrix b);
      SparseMatrix  Multiply ( SparseMatrix b);
 };
```
``` cpp
class  SparseMatrix;
class  MatrixTerm {
friend class SparseMatrix;
Private:
    int row, col, value;
};
```
* 转置
 ```cpp
 SparseMatrix SparseMatrix::Transpose()
{ // return the transpose of *this
	SparseMatrix b(cols, rows, terms);
	if (terms > 0)
	{ //nonzero matrix
		int currentB = 0;
		for (int c = 0; c < cols; c++)		// transpose by columns
			for (int i = 0; i < terms; i++) // find and move terms in column c
				if (smArray[i].col == c)
				{
					b.smArray[CurrentB].row = c;
					b.smArray[CurrentB].col = smArray[i].row;
					b.smArray[CurrentB++].value = smArray[i].value;
				}
	} // end of if (terms > 0)
	return b;
}
```
* 快速转置
``` cpp
 SparseMatrix SparseMatrix::FastTranspose()
{ // return the transpose of *this in O(terms+cols) time.
	SparseMatrix b(cols, rows, terms);
	if (terms > 0)
	{ // nonzero matrix
		int *rowSize = new int[cols];
		7int *rowStart = new int[cols];
		// compute rowSize[i] = number of terms in row i of b
		fill(rowSize, rowSize + cols, 0); // initialze
		for (i = 0; i < terms; i++)
			rowSize[smArray[i].col]++;
		// rowStart[i] = starting position of row i in b
		rowStart[0] = 0;
		for (i = 1; i < cols; i++)
			rowStart[i] = rowStart[i - 1] + rowSize[i - 1];
		for (i = 0; i < terms; i++)
		{ // copy from *this to b
			int j = rowStart[smArray[i].col];
			b.smArray[j].row = smArray[i].col;
			b.smArray[j].col = smArray[i].row;
			b.smArray[j].value = smArray[i].value;
			rowStart[smArray[i].col]++;
		} // end of for
		delete[] rowSize;
		delete[] rowStart;
	} // end of if
	return b;
}
```
* 时间复杂度
$O(cols+terms)$

## 字符串匹配算法

## 1. 暴力匹配法
定义现有文本串S模式串P，假设现在文本串S匹配到i位置，模式串P匹配到j位置，则有：
* 如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；
*如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。


``` cpp
int ViolentMatch(char* s, char* p)
{
	int sLen = strlen(s);
	int pLen = strlen(p);

	int i = 0;
	int j = 0;
	while (i < sLen && j < pLen)
	{
		if (s[i] == p[j])
		{
			//当前字符匹配成功（即S[i] == P[j]），则i++，j++
			i++;
			j++;
		}
		else
		{
			//失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0
			i = i - j + 1;
			j = 0;
		}
	}
	//匹配成功，返回模式串p在文本串s中的位置，否则返回-1
	if (j == pLen)
		return i - j;
	else
		return -1;
}
```
>		暴力匹配法没有利用已经匹配过的信息，实现简单但是效率低下。
***

## 2.KMP算法
* 算法流程
  * 假设现在文本串S匹配到i位置，模式串P匹配到j位置
    * 如果j=-1，或者当前字符匹配成功（S[i]==P[j]），都令i++，j++，继续匹配下一个字符；
    * 如果j!=-1，且当前字符匹配失败（S[i]!=P[j]），则令i不变，j =next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j-next[j] 位。\
  	（当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文阐述），即移动的实际位数为j-next[j]，且此值大于等于1。next数组的值代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next[j]=k，代表j之前的字符串中有最大长度为k 的相同前缀后缀。此也意味着在某个字符失配时，该字符对应的next值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next[j]的位置）。如果next[j]等于0或-1，则跳到模式串的开头字符，若next[j]=k且k>0，代表下次匹配跳到j之前的某个字符，而不是跳到开头，且具体跳过了k个字符。)
``` cpp
int KmpSearch(char* s, char* p)
{
	int i = 0;
	int j = 0;
	int sLen = strlen(s);
	int pLen = strlen(p);
	while (i < sLen && j < pLen)
	{
		//如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++
		if (j == -1 || s[i] == p[j])
		{

			i++;
			j++;
		}
		else
		{
			//如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]
			//next[j]即为j所对应的next值
			j = next[j];
		}
	}
	if (j == pLen)
		return i - j;
	else
		return -1;
}
```
* 步骤
1.  寻找前缀后缀最长公共元素长度
	对于P = p0 p1 ...pj-1 pj，寻找模式串P中长度最大且相等的前缀和后缀。如果存在p0 p1 ...pk-1 pk = pj- k pj-k+1...pj-1 pj，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。举个例子，如果给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示：

|模式串|a|b|a|b|
|-|-|-|-|-|
|最大前缀后缀公共元素长度|0|0|1|2|
> 比如对于字符串aba来说，它有长度为1的相同前缀后缀a；而对于字符串abab来说，它有长度为2的相同前缀后缀ab（相同前缀后缀的长度为k+1，k+1=2）。
2. 求next数组
	next数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为-1，如下表格所示：

|模式串|a|b|a|b|
|-|-|-|-|-|
|next数组|-1|0|0|1|

3. 根据next数组进行匹配

	匹配失配，$j=next[j]$，模式串向右移动的位数为：$j-next[j]$。换言之，当模式串的后缀$pj-kpj-k+1,...,pj-1$跟文本串$si-ksi-k+1,...,si-1$匹配成功，但$pj$跟$si$匹配失败时，因为$next[j]=k$，相当于在不包含pj的模式串中有最大长度为k的相同前缀后缀，即$p0p1...pk-1=pj-kpj-k+1...pj-1$，故令$j=next[j]$，从而让模式串右移$j-next[j]$位，使得模式串的前缀$p0p1,...,pk-1$对应着文本串$si-ksi-k+1,...,si-1$，而后让$pk$跟$s$i继续匹配。如下图所示：
		![](数据结构小结/0000.jpg){% asset_img 0000.jpg %}

## 解释
* 寻找最长前缀后缀
	*  如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示： ![](数据结构小结/0001.jpg){% asset_img 0001.jpg %}

   也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为：
![](数据结构小结/0002.jpg){% asset_img 0002.jpg %}

``` cpp
void GetNext(char* p,int next[])
{
	int pLen = strlen(p);
	next[0] = -1;
	int k = -1;
	int j = 0;
	while (j < pLen - 1)
	{
		//p[k]表示前缀，p[j]表示后缀
		if (k == -1 || p[j] == p[k])
		{
			++k;
			++j;
			next[j] = k;
		}
		else
		{
			k = next[k];
		}
	}
}
```
## 波兰式
将中缀表达式转换为前缀表达式

    转换步骤如下:

    初始化两个栈:运算符栈s1，储存中间结果的栈s2
    从右至左扫描中缀表达式
    遇到操作数时，将其压入s2
    遇到运算符时，比较其与s1栈顶运算符的优先级
        如果s1为空，或栈顶运算符为右括号“)”，则直接将此运算符入栈
        否则，若优先级比栈顶运算符的较高或相等，也将运算符压入s1
        否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较
    遇到括号时
        如果是右括号“)”，则直接压入s1
        如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃
    重复步骤2至5，直到表达式的最左边
    将s1中剩余的运算符依次弹出并压入s2
    依次弹出s2中的元素并输出，结果即为中缀表达式对应的前缀表达式

		    例如:1+((2+3)×4)-5具体过程，如下表

			扫描到的元素 	S2(栈底->栈顶) 	S1 (栈底->栈顶) 	说明
			5 	5 	空 	数字，直接入栈
			- 	5 	- 	s1为空，运算符直接入栈
			) 	5 	-) 	右括号直接入栈
			4 	5 4 	-) 	数字直接入栈
			x 	5 4 	-)x 	s1栈顶是右括号，直接入栈
			) 	5 4 	-)x) 	右括号直接入栈
			3 	5 4 3 	-)x) 	数字
			+ 	5 4 3 	-)x)+ 	s1栈顶是右括号，直接入栈
			2 	5 4 3 2 	-)x)+ 	数字
			( 	5 4 3 2 + 	-)x 	左括号，弹出运算符直至遇到右括号
			( 	5 4 3 2 + x 	- 	同上
			+ 	5 4 3 2 + x 	-+ 	优先级与-相同，入栈
			1 	5 4 3 2 + x 1 	-+ 	数字
			到达最左端 	5 4 3 2 + x 1 + - 	空 	s1剩余运算符

			    结果是:- + 1 × + 2 3 4 5
实现

``` java

public class Operation {
    private static int ADDITION=1;
    private static int SUBTRACTION=1;
    private static int MULTIPLICATION=2;
    private static int DIVISION=2;

    public static int getValue(String operation){
        int result;
        switch (operation){
            case "+":
                result=ADDITION;
                break;
            case "-":
                result=SUBTRACTION;
                break;
            case "*":
                result=MULTIPLICATION;
                break;
            case "/":
                result=DIVISION;
                break;
            default:
//                System.out.println("不存在该运算符");
                result=0;
        }
        return result;
    }
}



public class PolishNotation {

    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        System.out.println("请输入运算表达式:");
        String expressionStr=sc.nextLine();
//        System.out.println(expressionStr);
        List<String> zx= toInfixExpression(expressionStr);
        List<String> rpn=parseSuffixExpression(zx);
        String rpnStr="";
        for(String str:rpn){
            rpnStr+=str;
        }
        System.out.println(rpnStr);

        System.out.println("计算结果:"+ calculate(rpn));
    }

    /**
     * 把字符串转换成中序表达式
     * @param s
     * @return
     */
    public static List<String> toInfixExpression(String s) {
        List<String> ls = new ArrayList<String>();//存储中序表达式
        int i = 0;
        String str;
        char c;
        do {
            if ((c = s.charAt(i)) < 48 || (c = s.charAt(i)) > 57) {
                ls.add("" + c);
                i++;
            } else {
                str = "";
                while (i < s.length() && (c = s.charAt(i)) >= 48
                        && (c = s.charAt(i)) <= 57) {
                    str += c;
                    i++;
                }
                ls.add(str);
            }

        } while (i < s.length());
        return ls;
    }

    /**
     * 转换成逆波兰表达式
     * @param ls
     * @return
     */
    public static List<String> parseSuffixExpression(List<String> ls) {
        Stack<String> s1=new Stack<String>();
        Stack<String> s2=new Stack<String>();
        List<String> lss = new ArrayList<String>();
        for (String ss : ls) {
            if (ss.matches("\\d+")) {
                lss.add(ss);
            } else if (ss.equals("(")) {
                s1.push(ss);
            } else if (ss.equals(")")) {

                while (!s1.peek().equals("(")) {
                    lss.add(s1.pop());
                }
                s1.pop();
            } else {
                while (s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(ss)) {
                    lss.add(s1.pop());
                }
                s1.push(ss);
            }
        }
        while (s1.size() != 0) {
            lss.add(s1.pop());
        }
        return lss;
    }

    /**
     * 通过逆波兰表达式计算结果
     * @param ls
     * @return
     */
    public static int calculate(List<String> ls) {
        Stack<String> s=new Stack<String>();
        for (String str : ls) {
            if (str.matches("\\d+")) {
                s.push(str);
            } else {
                int b = Integer.parseInt(s.pop());
                int a = Integer.parseInt(s.pop());
                int result=0;
                if (str.equals("+")) {
                    result = a + b;
                } else if (str.equals("-")) {
                    result = a - b;
                } else if (str.equals("*")) {
                    result = a * b;
                } else if (str.equals("\\")) {
                    result = a / b;
                }
                s.push("" + result);
            }
        }
        System.out.println(s.peek());
        return Integer.parseInt(s.pop());
    }
}
```
二叉树
``` cpp

#include<iostream.h>
struct tree
{
    int data;
    tree *left,*right;
};
class Btree
{
    static int n;
    static int m;
public:
    tree *root;
    Btree()
    {
        root=NULL;
    }
    void create_Btree(int);
    void Preorder(tree *);                  //先序遍历
    void inorder(tree *);                   //中序遍历
    void Postorder(tree *);                 //后序遍历
    void display1() {Preorder(root); cout<<endl;}
    void display2() {inorder(root);cout<<endl;}
    void display3() {Postorder(root); cout<<endl;}
    int count(tree *);                      //计算二叉树的个数
    int findleaf(tree *);                   //求二叉树叶子的个数
    int findnode(tree *);                   //求二叉树中度数为1的结点数量,这是当初考数据结构时候的最后一道题目
};
int Btree::n=0;
int Btree::m=0;
void Btree::create_Btree(int x)
{
    tree *newnode=new tree;
    newnode->data=x;
    newnode->right=newnode->left=NULL;
    if(root==NULL)
        root=newnode;
    else
    {
        tree *back;
        tree *current=root;
        while(current!=NULL)
        {
            back=current;
            if(current->data>x)
                current=current->left;
            else
                current=current->right;
        }
        if(back->data>x)
            back->left=newnode;
        else
            back->right=newnode;
    }
}
int Btree::count(tree *p)
{
    if(p==NULL)
        return 0;
    else
        return count(p->left)+count(p->right)+1;      //这是运用了函数嵌套即递归的方法。
}
void Btree::Preorder(tree *temp)    //这是先序遍历二叉树，采用了递归的方法。
{
    if(temp!=NULL)
    {
        cout<<temp->data<<" ";
        Preorder(temp->left);
        Preorder(temp->right);
    }
}
void Btree::inorder(tree *temp)      //这是中序遍历二叉树，采用了递归的方法。
{
    if(temp!=NULL)
    {
        inorder(temp->left);
        cout<<temp->data<<" ";
        inorder(temp->right);
    }
}
void Btree::Postorder(tree *temp)     //这是后序遍历二叉树，采用了递归的方法。
{
    if(temp!=NULL)
    {
        Postorder(temp->left);
        Postorder(temp->right);
        cout<<temp->data<<" ";
    }
}
int Btree::findleaf(tree *temp)
{
    if(temp==NULL)return 0;
    else
    {
        if(temp->left==NULL&&temp->right==NULL)return n+=1;
        else
        {
            findleaf(temp->left);
            findleaf(temp->right);
        }
        return n;
    }
}
int Btree::findnode(tree *temp)
{
    if(temp==NULL)return 0;
    else
    {
        if(temp->left!=NULL&&temp->right!=NULL)
        {
            findnode(temp->left);
            findnode(temp->right);
        }
        if(temp->left!=NULL&&temp->right==NULL)
        {
            m+=1;
            findnode(temp->left);
        }
        if(temp->left==NULL&&temp->right!=NULL)
        {
            m+=1;
            findnode(temp->right);
        }
    }
    return m;
}


void main()
{
    Btree A;
    int array[]={7,4,2,3,15,35,6,45,55,20,1,14,56,57,58};
    int k;
    k=sizeof(array)/sizeof(array[0]);
    cout<<"建立排序二叉树顺序: "<<endl;
    for(int i=0;i<k;i++)
    {
        cout<<array[i]<<" ";
        A.create_Btree(array[i]);
    }
    cout<<endl;
    cout<<"二叉树节点个数： "<<A.count(A.root)<<endl;
    cout<<"二叉树叶子个数："<<A.findleaf(A.root)<<endl;
    cout<<"二叉树中度数为1的结点的数量为："<<A.findnode(A.root)<<endl;
    cout<<endl<<"先序遍历序列: "<<endl;
    A.display1();
    cout<<endl<<"中序遍历序列: "<<endl;
    A.display2();
    cout<<endl<<"后序遍历序列: "<<endl;
    A.display3();
}
```
堆
``` cpp
#include <vector>
#include <cassert>
 using namespace std;
class MaxHeap
{
  private:
	vector<int> heap;
	int size;

  public:
	void make_heap(vector<int> & nums, int s)
	{ //构建堆
		heap.assign(nums.begin(), nums.end());
		size = s;
		for (int i = size / 2 - 1; i >= 0; i--)
			down(i);
	}
	void push(int num)
	{ //插入元素
		heap.push_back(num);
		size++;
		up(size - 1);
	}
	int pop()
	{ //删除元素
		assert(size > 0);
		int result = heap[0];
		heap[0] = heap[size - 1];
		heap.pop_back();
		size--;
		down(0);
		return result;
	}
	void down(int index)
	{
		assert(index >= 0);
		int temp = heap[index];
		index = index * 2 + 1;
		while (index < size)
		{
			if (index + 1 < size && heap[index] < heap[index + 1])
				index++;
			if (heap[index] < temp)
				break;
			else
			{
				heap[(index - 1) / 2] = heap[index];
				index = index * 2 + 1;
			}
		}
		heap[(index - 1) / 2] = temp;
	}
	void up(int index)
	{
		assert(index < size);
		int temp = heap[index];
		while (index > 0 && temp > heap[(index - 1) / 2])
		{
			heap[index] = heap[(index - 1) / 2];
			index = (index - 1) / 2;
		}
		heap[index] = temp;
	}
};

```
胜者树
``` cpp
#include <stdio.h>
 #define K 10
 #define MAX 65535
 int leaves[K+1];
 int successTree[K];

 /* 对于单个内部节点进行调整 */
 void adjust(int i)
 {
     int m,n;
     if(2 * i < K)               /* 获取它的左孩子结点 */
         m = successTree[2 * i];
     else
         m = 2 * i - K + 1;
     if(2*i+1<K)                 /* 获取它的右孩子节点 */
         n = successTree[2*i+1];
     else
         n = 2 * i + - K + 2;
     successTree[i] = leaves[m] > leaves[n] ? n : m; /* 进行胜负判定 */
 }
 /* 初始化叶子节点并对内部节点进行类似于堆的调整 */
 void initTree()
 {
     for(int i=1;i<K+1;i++)
         scanf("%d", &leaves[i]);
     for(int i=K-1;i>0;i--)
         adjust(i);
 }
 /* 自下而上对胜者树进行调整 */
 void adjustToRoot(int i)
 {
     int parent = (i + K - 1) / 2; /* 对从当前节点到根节点路径上的所有
                                    * 节点进行调整 */
     while(parent>0)
     {
         adjust(parent);
         parent = parent / 2;
     }
 }

 int main()
 {
     freopen("in","r",stdin);
     initTree();
     for(int i=1;i<K+1;i++)      /* 每次用最大值替换掉冠军节点，并对树
                                  * 进行调整,最终得到升序排序的序列 */
     {
         printf("%d ", leaves[successTree[1]]);
         leaves[successTree[1]]=MAX;
         adjustToRoot(successTree[1]);
     }
     return 0;
 }
```
败者树
``` cpp
int loserTree[K];               /* 存储中间节点值，下标0处存储冠军节点 */
int leaves[K+1];                /* 从下标1开始存储叶子节点值，下标0处存储一个最小值节点 */

void adjust(int i)
{
    int parent=(i+K-1)/2;      /* 求出父节点的下标 */
    while(parent>0)
    {
        if(leaves[i]>leaves[loserTree[parent]])
        {
            int temp=loserTree[parent];
            loserTree[parent]=i;
            /* i指向的是优胜者 */
            i= temp;
        }
        parent = parent / 2;
    }
    loserTree[0]=i;
}

void initLoserTree()
{
    int i;
    for(i=1;i<K+1;i++)
        scanf("%d",&leaves[i]);
    leaves[0]=MIN;
    for(int i=0;i<K;i++)
        loserTree[i]=0;
    for(int i=K;i>0;i--)
        adjust(i);
}
```
最小生成树
``` cpp
typedef struct
{
    char vertex[VertexNum];                                //顶点表
    int edges[VertexNum][VertexNum];                       //邻接矩阵,可看做边表
    int n,e;                                               //图中当前的顶点数和边数
}MGraph;

typedef struct node
{
    int u;                                                 //边的起始顶点
    int v;                                                 //边的终止顶点
    int w;                                                 //边的权值
}Edge;

void kruskal(MGraph G)
{
    int i,j,u1,v1,sn1,sn2,k;
    int vset[VertexNum];                                    //辅助数组，判定两个顶点是否连通
    int E[EdgeNum];                                         //存放所有的边
    k=0;                                                    //E数组的下标从0开始
    for (i=0;i<G.n;i++)
    {
        for (j=0;j<G.n;j++)
        {
            if (G.edges[i][j]!=0 && G.edges[i][j]!=INF)
            {
                E[k].u=i;
                E[k].v=j;
                E[k].w=G.edges[i][j];
                k++;
            }
        }
    }
    heapsort(E,k,sizeof(E[0]));                            //堆排序，按权值从小到大排列
    for (i=0;i<G.n;i++)                                    //初始化辅助数组
    {
        vset[i]=i;
    }
    k=1;                                                   //生成的边数，最后要刚好为总边数
    j=0;                                                   //E中的下标
    while (k<G.n)
    {
        sn1=vset[E[j].u];
        sn2=vset[E[j].v];                                  //得到两顶点属于的集合编号
        if (sn1!=sn2)                                      //不在同一集合编号内的话，把边加入最小生成树
        {
            printf("%d ---> %d, %d",E[j].u,E[j].v,E[j].w);
            k++;
            for (i=0;i<G.n;i++)
            {
                if (vset[i]==sn2)
                {
                    vset[i]=sn1;
                }
            }
        }
        j++;
    }
}
```
``` cpp
// 单源最短路径Dijkstra算法实现.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include<iostream>
#define MAX 200
#define Infinity 65535
using namespace std;

//边尾节点信息结构体
struct edgeNode
{
 int no;   //尾接点序号
 int cost;  //边权值
 edgeNode *next; //其下一条邻接边尾节点指针
};

//节点信息结构体
struct vexNode
{
 char info;  //节点名称
 edgeNode *link; //与其相连的边的尾节点链表指针
};

struct Queue
{
 int no; //队列中节点序号
 int cost; //以此为尾节点的边的权值
};

//优先队列
Queue priQue[MAX];
//节点数组
vexNode adjlist[MAX];
//指定源点到节点i的最短路径花费
int lowcost[MAX];
//指定源点到节点i路径中，节点i的前驱节点序号
int parent[MAX];

//建立图邻接表
void createGraph(vexNode *adjlist,int *parent,int * lowcost,const int n,const int e)
{
 int i;
 for(i=1;i<=n;i++)
 {
  cout<<"请输入节点"<<i<<"的名称：";
  cin>>adjlist[i].info;
  adjlist[i].link = NULL;
  lowcost[i] = Infinity;
  parent[i] = i;
 }
 edgeNode *p1;
   int v1,v2;
 for(i=1;i<=e;i++)
 {
  cout<<"请输入边"<<i<<"的起始节点与尾节点序号：";
  cin>>v1>>v2;
  p1 = (edgeNode*)malloc(sizeof(edgeNode));
  p1->no = v2;
  cout<<"此边的权值：";
  cin>>p1->cost;
  p1->next = adjlist[v1].link;
  adjlist[v1].link = p1;
 }
}
//当插入节点到优先队列时，保持队列优先性
void keep_min_heap(Queue *priQue,int &num,const int k)
{
 int l = 2*k;
 int r = 2*k + 1;
 int smallest = k;
 if(l<=num&&priQue[l].cost<priQue[k].cost)
  smallest = l;
 if(r<=num&&priQue[r].cost<priQue[smallest].cost)
  smallest = r;
 if(smallest != k)
 {
  Queue temp = priQue[smallest];
  priQue[smallest] = priQue[k];
  priQue[k] = temp;
  keep_min_heap(priQue,num,smallest);
 }
}

//插入节点到优先队列时并且保持队列优先性
void heap_insert(Queue *priQue,int &num,int no,int cost)
{
 num +=1;
 priQue[num].no = no;
 priQue[num].cost = cost;
 int i = num;
 while(i>1&&priQue[i/2].cost>priQue[i].cost)
 {
  Queue temp = priQue[i];
  priQue[i] = priQue[i/2];
  priQue[i/2] = temp;
  i = i/2;
 }
}
//取出优先队列的队头元素
Queue heap_extract_min(Queue *priQue,int &num)
{
 if(num<1)
  return priQue[0];
 Queue min = priQue[1];
 priQue[1] = priQue[num];
 num -=1;
 keep_min_heap(priQue,num,1);
 return min;
}

//打印指定源点带序号为i的点的最短路径
void print_it(int *parent,vexNode *adjlist,int v)
{
 if(parent[v] == v)
  cout<<"("<<v<<":"<<adjlist[v].info<<") ";
 else
 {
  print_it(parent,adjlist,parent[v]);
  cout<<"("<<v<<":"<<adjlist[v].info<<") ";
 }
}

int _tmain(int argc, _TCHAR* argv[])
{
int cases;
 cout<<"请输入案例的个数：";
 cin>>cases;
 while(cases--)
 {
  int n,e;
  cout<<"请输入节点数：";
  cin>>n;
  cout<<"请输入边数：";
  cin>>e;
  //队列中的元素，初始为0
  int num = 0;
  int i;
  //创建邻接表
  createGraph(adjlist,parent,lowcost,n,e);
  cout<<endl;
  cout<<"从哪个节点开始：";
  int v0;
  cin>>v0;
  int v =v0;
  lowcost[v0] = 0;
  cout<<endl;
  Queue queue;

  for(i=1;i<n;i++)
  {
   edgeNode *p = adjlist[v0].link;
   while(p != NULL)
   {

    if(lowcost[v0] + p->cost<lowcost[p->no])
    {
     lowcost[p->no] = lowcost[v0] + p->cost;
     parent[p->no] = v0;
     heap_insert(priQue,num,p->no,lowcost[p->no]);
    }
    p = p->next;
   }
   queue = heap_extract_min(priQue,num);
   v0 = queue.no;
  }
  for(i=1;i<=n;i++)
  {
   mincost = 0;
   cout<<"从点"<<adjlist[v].info<<"开始到"<<adjlist[i].info<<"的最短路径为："<<endl;
   print_it(parent,adjlist,i);
   cout<<endl;
   cout<<"距离为："<<lowcost[i]<<endl;
  }
 }
 system("pause");
 return 0;
}
```
AOV
```
#include <stdio.h>
#include <malloc.h>
#define max 100
typedef struct arcnode
{
	int adjvex;
	struct arcnode *next;
} arcnode;
typedef struct
{
	int vertex;
	arcnode *firstarc;
} vexnode;
vexnode adjlist[max];
int creatadjlist()
{
	arcnode *ptr;
	int arcnum, vexnum, k, v1, v2;
	printf("input vexnum and arcnum:");
	scanf("%d,%d", &vexnum, &arcnum);
	for (k = 1; k <= vexnum; k++)
	{
		adjlist[k].firstarc = NULL;
		adjlist[k].vertex = 0;
	}
	for (k = 1; k <= arcnum; k++)
	{
		printf("v1,v2=");
		scanf("%d,%d", &v1, &v2);
		ptr = (arcnode *)malloc(sizeof(arcnode));
		ptr->adjvex = v2;
		ptr->next = adjlist[v1].firstarc;
		adjlist[v1].firstarc = ptr;
		adjlist[v2].vertex++;
	}
	return vexnum;
}
toposort(int n)
{
	int queue[max];
	int front = 0, rear = 0;
	int v, w, m;
	arcnode *p;
	m = 0;
	for (v = 1; v <= n; v++)
		if (adjlist[v].vertex == 0)
		{
			rear = (rear + 1) % max;
			queue[rear] = v;
		}
	printf("the toposort:\n");
	while (front != rear)
	{
		front = (front + 1) % max;
		v = queue[front];
		printf("%d ", v);
		m++;
		p = adjlist[v].firstarc;
		while (p != NULL)
		{
			w = p->adjvex;
			adjlist[w].vertex--;
			if (adjlist[w].vertex == 0)
			{
				rear = (rear + 1) % max;
				queue[rear] = w;
			}
			p = p->next;
		}
	}
	if (m < n)
		printf("the toposort is fail.");
}
int main()
{
	int n;
	n = creatadjlist();
	toposort(n);
	return 0;
}
```
AOE
```
#include<iostream>
using namespace std;

#define MAXN 100		//顶点个数最大值
#define MAXM 200		//边数的最大值

struct ArcNode
{
	int to, dur, no;	//边的另一个顶点、持续时间、活动序号
	ArcNode *next;
};
int n, m;				//顶点个数、边数
ArcNode *List1[MAXN];	//每个顶点的边链表表头指针（出边表）
ArcNode *List2[MAXM];	//每个顶点的边链表表头指针（入边表）
int count1[MAXN];		//各顶点的入度
int count2[MAXM];		//各顶点的出度
int Ee[MAXN];			//各事件的最早可能开始时间
int El[MAXN];			//各事件的最迟允许开始时间
int e[MAXM];			//各活动的最早可能开始时间
int L[MAXM];			//各活动的最迟允许开始时间
void CriticalPath()		//求关键路径
{
	//拓扑排序求Ee
	int i, j, k;
	int top1 = -1;
	ArcNode *temp1;
	memset(Ee, 0, sizeof(Ee));
	for(i = 0; i < n; i++)
		if(count1[i] == 0) { count1[i] = top1; top1 = i; }
	for(i = 0; i < n; i++)
	{
		if(top1 == -1) { printf("Network has a cycle!\n"); return; }
		else
		{
			j = top1; top1 = count1[top1];
			temp1 = List1[j];
			while(temp1 != NULL)
			{
				k = temp1->to;
				if(--count1[k] == 0) { count1[k] = top1; top1 = k; }
				if(Ee[j]+temp1->dur > Ee[k]) Ee[k] = Ee[j] + temp1->dur;//有向边<j, k>
				temp1 = temp1->next;
			}
		}
	}
	//逆拓扑排序求El
	int top2 = -1;
	ArcNode *temp2;
	for(i = 0; i < n; i++)
	{
		El[i] = Ee[n-1];
		if(count2[i] == 0) { count2[i] = top2; top2 = i; }
	}
	for(i = 0; i < n; i++)
	{
		j = top2; top2 = count2[top2];
		temp2 = List2[j];
		while(temp2 != NULL)
		{
			k = temp2->to;
			if(--count2[k] == 0) { count2[k] = top2; top2 = k; }
			if(El[j]-temp2->dur < El[k]) El[k] = El[j] - temp2->dur;//有向边<k, j>
			temp2 = temp2->next;
		}
	}
	//求各活动的e[k]和L[k]
	memset(e, 0, sizeof(e)); memset(L, 0, sizeof(L));
	printf("The Critical activities are:\n");
	for(i = 0; i < n; i++)
	{
		temp1 = List1[i];
		while(temp1 != NULL)
		{
			j = temp1->to; k = temp1->no;	//有向边<i, j>
			e[k] = Ee[i]; L[k] = El[j] - temp1->dur;
			if(e[k] == L[k]) printf("a%d : %d->%d\n", k, i, j);
			temp1 = temp1->next;
		}
	}
}
int main()
{
	int i, u, v, w;	//循环变量、边的起点和终点
	scanf("%d%d", &n, &m);	//读入顶点个数和边数
	memset(List1, 0, sizeof(List1)); memset(List2, 0, sizeof(List2));
	memset(count1, 0, sizeof(count1)); memset(count2, 0, sizeof(count2));
	ArcNode *temp1, *temp2;
	for(i = 0; i < m; i++)
	{
		scanf("%d%d%d", &u, &v, &w);	//读入边的起点和终点
		count1[v]++;
		temp1 = new ArcNode;			//构造邻接表
		temp1->to = v; temp1->dur = w;
		temp1->no = i + 1; temp1->next = NULL;
		if(List1[u] == NULL) List1[u] = temp1;
		else { temp1->next = List1[u]; List1[u] = temp1; }
		count2[u]++;
		temp2 = new ArcNode;			//构造逆邻接表
		temp2->to = u; temp2->dur = w;
		temp2->no = i + 1; temp2->next = NULL;
		if(List2[v] == NULL) List2[v] = temp2;
		else { temp2->next = List2[v]; List2[v] = temp2; }
	}
	CriticalPath();
	for(i = 0; i < n; i++)				//释放边链表上各边结点所占用的存储空间
	{
		temp1 = List1[i]; temp2 = List2[i];
		while(temp1 != NULL) { List1[i] = temp1->next; delete temp1; temp1 = List1[i]; }
		while(temp2 != NULL) { List2[i] = temp2->next; delete temp2; temp2 = List2[i]; }
	}
	return 0;
}
```